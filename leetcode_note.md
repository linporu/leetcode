# LeetCode 解題技巧筆記

## 第一章：基礎資料結構與演算法

### 1.1 陣列（Array）操作

- 基本操作：遍歷、插入、刪除
- Two Pointers 技巧
  - [283] Move Zeroes：使用雙指針移動元素
  - [88] Merge Sorted Array：合併排序陣列
- 前綴和（Prefix Sum）
  - [1480] Running Sum of 1D Array

### 1.2 二分搜尋（Binary Search）

- 基本二分搜尋
  - [704] Binary Search：標準二分搜尋實作
  - [35] Search Insert Position：找插入位置

### 1.3 雜湊表（Hash Table）

- 計數與查找
  - [1] Two Sum：使用 HashMap 優化查找
  - [383] Ransom Note：字符頻率統計
- 多數元素問題
  - [169] Majority Element：基本多數元素
  - [229] Majority Element II：進階多數元素

### 1.4 鏈結串列（Linked List）

- 基本操作
  - [206] Reverse Linked List：反轉鏈結串列
  - [876] Middle of Linked List：尋找中間節點
- 進階技巧
  - [234] Palindrome Linked List：判斷回文
  - [143] Reorder List：重排鏈結串列
- 特殊問題
  - [141] Linked List Cycle：環形檢測
  - [142] Linked List Cycle II：找環形起點
  - [160] Intersection of Two Linked Lists：交點檢測

### 1.5 字串處理（String）

- 基本操作
  - [14] Longest Common Prefix：最長共同前綴
  - [13] Roman to Integer：羅馬數字轉換

## 第二章：常見解題模式

### 2.1 Two Pointers 模式

雙指針是一種常見的演算法技巧，通過使用兩個指針來遍歷或處理資料結構。這種技巧通常可以將時間複雜度從 O(n²) 優化到 O(n)。

#### 2.1.1 同向雙指針（Fast-Slow Pointers）

- 特點：兩個指針朝同一個方向移動，但速度可能不同
- 適用場景：
  - 陣列中移除特定元素
  - 尋找特定模式的子序列
  - 判斷鏈結串列是否有環
- 經典題目：
  - [283] Move Zeroes：將陣列中的 0 移到末尾
    - 技巧：使用快慢指針，慢指針指向待填入非零元素的位置
    - 時間複雜度：O(n)，空間複雜度：O(1)
  - [141] Linked List Cycle：檢測鏈結串列是否有環
    - 技巧：快指針每次走兩步，慢指針每次走一步
    - 原理：如果有環，快慢指針終將相遇

#### 2.1.2 相向雙指針（Two-End Pointers）

- 特點：兩個指針從陣列的兩端向中間移動
- 適用場景：
  - 排序陣列的搜尋問題
  - 回文字串判斷
  - 盛水容器類問題
- 經典題目：
  - [234] Palindrome Linked List：判斷鏈結串列是否為回文
    - 技巧：快慢指針找中點 + 反轉後半部 + 相向比較
    - 時間複雜度：O(n)，空間複雜度：O(1)

#### 2.1.3 滑動窗口（Sliding Window）

滑動窗口是雙指針技巧的一個重要延伸應用。它通過維護一個「窗口」來解決子陣列或子字串的問題，是一種特殊且強大的技巧，值得特別關注。

- 基本特點：
  - 使用兩個指針定義一個窗口範圍
  - 窗口通常是連續的區間
  - 透過同向移動來「滑動」窗口

由於滑動窗口有其獨特的應用場景和解題模式，我們會在 2.2 節中詳細討論這個技巧。

#### 2.1.4 常見解題模式

1. 初始化：

   ```python
   left = 0
   right = len(array) - 1  # 相向雙指針
   # 或
   slow = fast = 0  # 同向雙指針
   ```

2. 移動條件：

   - 同向：通常基於元素值或位置關係
   - 相向：通常基於左右指針的元素關係
   - 滑動窗口：基於窗口的特定條件

3. 終止條件：

   - 相向：left >= right
   - 同向：fast 到達終點
   - 特殊：如環形檢測中的相遇條件

4. 常見陷阱與注意事項：
   - 邊界條件的處理
   - 指針移動時的元素存取安全性
   - 迴圈終止條件的正確性
   - 特殊輸入的處理（空陣列、單元素等）

### 2.2 滑動窗口模式（Sliding Window）

滑動窗口是雙指針的一種特殊應用，通過維護一個「窗口」來解決子陣列或子字串的問題。

#### 2.2.1 基本概念

- 窗口定義：由左右兩個指針（left, right）定義的區間
- 窗口移動：通過移動左右指針來改變窗口大小和位置
- 窗口狀態：在窗口內維護某種狀態（如：和、最大值、最小值等）

#### 2.2.2 適用場景

1. 子陣列/子字串問題：

   - 尋找最長的符合條件的子字串
   - 尋找最短的符合條件的子陣列
   - 判斷是否存在符合條件的子序列

2. 計數問題：
   - 計算符合條件的子陣列個數
   - 統計字串中的字符頻率

#### 2.2.3 常見題型

1. 固定大小窗口：

   - 窗口大小固定不變
   - 每次移動時，只需更新窗口兩端的元素對狀態的影響
   - 例如：求長度為 k 的子陣列的最大平均值

2. 可變大小窗口：
   - 窗口大小根據條件動態調整
   - 通常使用 while 循環來收縮窗口
   - 例如：求和為 k 的最短子陣列

#### 2.2.4 解題模板

```python
def sliding_window(arr):
    left = right = 0
    window_state = init_state()  # 初始化窗口狀態

    while right < len(arr):
        # 1. 擴展窗口
        window_state.add(arr[right])
        right += 1

        # 2. 根據條件收縮窗口
        while need_shrink(window_state):
            window_state.remove(arr[left])
            left += 1

        # 3. 更新答案
        update_answer(window_state)

    return answer
```

#### 2.2.5 實作要點

1. 初始化：

   - 正確初始化左右指針
   - 設置適當的窗口狀態結構

2. 擴展窗口：

   - 添加右指針指向的元素
   - 更新窗口狀態

3. 收縮窗口：

   - 根據題目條件決定何時收縮
   - 移除左指針指向的元素
   - 更新窗口狀態

4. 更新答案：

   - 在適當的時機更新答案
   - 可能在擴展後或收縮後

5. 邊界處理：
   - 空陣列/字串的處理
   - 窗口大小的限制
   - 指針移動的合法性檢查

### 2.3 遞迴與回溯

遞迴是一種透過呼叫自身來解決問題的程式設計方法，而回溯則是遞迴的一種特殊應用。

#### 2.3.1 基本遞迴模式

遞迴解題的四個關鍵要素：

1. Base Case（基本情況）：

   - 最簡單的情況，可以直接返回結果
   - 用於終止遞迴呼叫
   - 例如：空串列或只有一個節點的情況

2. 遞迴假設：

   - 假設子問題已經解決
   - 專注於當前層級要做的事
   - 例如：假設後半部串列已經反轉完成

3. 遞迴處理：

   - 處理當前層級的邏輯
   - 將子問題的結果整合到當前層級
   - 確保不會破壞已完成的子問題結果

4. 返回結果：
   - 明確定義每層遞迴的返回值
   - 確保返回值能夠被上層正確使用

經典例題 [206] Reverse Linked List：

```python
def reverseList(self, head):
    # 1. Base Case
    if not head or not head.next:
        return head

    # 2. 遞迴假設：假設後面的串列已反轉完成
    new_head = self.reverseList(head.next)

    # 3. 處理當前層級
    head.next.next = head  # 改變指向
    head.next = None      # 避免循環

    # 4. 返回結果
    return new_head  # 持續返回新的頭節點
```

#### 2.3.2 回溯法則

回溯法是一種系統性地尋找所有可能解的方法：

1. 選擇：

   - 在當前狀態下，選擇下一步可能的操作
   - 通常需要一個選擇列表

2. 約束條件：

   - 定義什麼樣的選擇是合法的
   - 用於剪枝，避免無效的搜索路徑

3. 目標：
   - 明確定義什麼是一個完整的解
   - 決定何時收集結果

回溯解題模板：

```python
def backtrack(選擇列表, 路徑):
    if 滿足結束條件:
        收集結果
        return

    for 選擇 in 選擇列表:
        if 不符合約束條件:
            continue

        做選擇
        backtrack(新的選擇列表, 新的路徑)
        撤銷選擇
```

#### 2.3.3 效能優化

1. 剪枝技巧：

   - 提前判斷無效路徑
   - 跳過不可能的選擇
   - 善用約束條件

2. 記憶化：

   - 儲存已計算過的結果
   - 避免重複計算
   - 通常使用 HashMap 或陣列

3. 時空複雜度分析：

   - 遞迴深度對應到空間複雜度
   - 分支數量影響時間複雜度
   - 剪枝效果難以量化，但很重要

4. 常見陷阱：
   - 忘記處理 Base Case
   - 遞迴沒有實際進展
   - 忘記恢復狀態（回溯時）
   - 遞迴深度過大導致堆疊溢出

## 第三章：解題策略與技巧

### 3.1 複雜度分析

- 時間複雜度
- 空間複雜度
- 常見複雜度優化方法

### 3.2 邊界條件處理

- 空值檢查
- 邊界值處理
- 特殊情況考慮

### 3.3 程式碼優化

- 程式碼可讀性
- 變數命名規範
- 註解撰寫原則

## 第四章：進階主題

### 4.1 動態規劃

- 基本概念
- 常見題型
- 解題模板

### 4.2 圖論算法

- 圖的表示方法
- 常用圖論算法
- 實際應用案例

### 4.3 樹結構

- 二叉樹操作
- 搜尋樹特性
- 樹的遍歷方式

## 附錄

### A. 常用 Python 內建函數與模組

### B. 解題常用程式碼片段

### C. 題目分類索引
