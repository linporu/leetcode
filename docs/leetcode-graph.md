# Graph 圖論解題技巧與 LeetCode 學習清單

## 基本解題技巧

### 1. 圖的表示方法 (Graph Representation)

- 使用時機：
  - 需要表示節點間的關係
  - 需要處理有向或無向圖
  - 需要處理加權圖
- 實作重點：
  - 鄰接矩陣（Adjacency Matrix）
  - 鄰接列表（Adjacency List）
  - 邊列表（Edge List）
  - 選擇合適的表示方法考慮空間效率

### 2. 圖的遍歷 (Graph Traversal)

- 使用時機：
  - 需要訪問圖中所有節點
  - 需要找出特定路徑
  - 需要檢查連通性
- 實作重點：
  - 深度優先搜索（DFS）
  - 廣度優先搜索（BFS）
  - 訪問標記的管理
  - 處理環和重複訪問

### 3. 最短路徑 (Shortest Path)

- 使用時機：
  - 需要找出兩點間最短距離
  - 需要計算最小成本路徑
  - 需要處理加權圖的路徑問題
- 實作重點：
  - Dijkstra 算法
  - Floyd-Warshall 算法
  - Bellman-Ford 算法
  - 選擇合適的算法根據圖的特性
- 算法選擇依據：
  - BFS 適用於無權圖或權重相同的圖（所有邊的權重都是 1）
  - Dijkstra 適用於帶權圖，特別是權重不同的情況（無負權邊）
  - Bellman-Ford 適用於可能存在負權邊的圖
  - Floyd-Warshall 適用於需要計算所有點對最短路徑的情況

### 4. 拓撲排序 (Topological Sort)

- 使用時機：
  - 需要處理依賴關係
  - 需要安排任務順序
  - 需要檢測環的存在
- 實作重點：
  - 入度計算
  - 環的檢測
  - 排序結果的生成
  - BFS 或 DFS 的選擇

### 5. 並查集 (Union Find)

- 使用時機：
  - 需要處理圖的連通性
  - 需要合併集合
  - 需要檢測環
- 實作重點：
  - 路徑壓縮
  - 按秩合併
  - 集合的維護
  - 效率優化

## 練習題目

### 1. 圖的遍歷練習（由易到難）

#### Easy 題目

1. [733. Flood Fill](https://leetcode.com/problems/flood-fill/) (Easy)

   - 核心技巧：DFS/BFS 基礎應用
   - 時間複雜度：O(n×m)
   - 空間複雜度：O(n×m)
   - 學習重點：
     - 基本的 DFS/BFS 實現
     - 格子圖的遍歷
     - 訪問標記的處理

2. [1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/) (Easy)

   - 核心技巧：基本圖遍歷
   - 時間複雜度：O(V+E)
   - 空間複雜度：O(V)
   - 學習重點：
     - 圖的連通性判斷
     - DFS/BFS 的選擇
     - 基本圖結構操作

3. [463. Island Perimeter](https://leetcode.com/problems/island-perimeter/) (Easy)
   - 核心技巧：網格遍歷
   - 時間複雜度：O(n×m)
   - 空間複雜度：O(1)
   - 學習重點：
     - 邊界判斷
     - 相鄰關係處理
     - 網格特性應用

#### Medium 題目

1. [200. Number of Islands](https://leetcode.com/problems/number-of-islands/) (Medium)

   - 核心技巧：連通分量計數
   - 時間複雜度：O(n×m)
   - 空間複雜度：O(n×m)
   - 學習重點：
     - DFS/BFS 的應用
     - 連通分量的識別
     - 訪問標記的優化

2. [547. Number of Provinces](https://leetcode.com/problems/number-of-provinces/) (Medium)

   - 核心技巧：圖的連通性
   - 時間複雜度：O(n²)
   - 空間複雜度：O(n)
   - 學習重點：
     - 鄰接矩陣的處理
     - DFS/BFS vs 並查集
     - 不同解法的比較

3. [797. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/) (Medium)
   - 核心技巧：路徑搜索
   - 時間複雜度：O(2^n)
   - 空間複雜度：O(n)
   - 學習重點：
     - 路徑記錄
     - 回溯處理
     - 有向無環圖特性

### 2. 最短路徑練習（由易到難）

#### Easy 題目

1. [111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/) (Easy)

   - 核心技巧：BFS 最短路徑
   - 時間複雜度：O(n)
   - 空間複雜度：O(w)，w 為樹的最大寬度
   - 學習重點：
     - BFS 找最短路徑
     - 層次遍歷
     - 終止條件判斷

2. [1030. Matrix Cells in Distance Order](https://leetcode.com/problems/matrix-cells-in-distance-order/) (Easy)
   - 核心技巧：距離排序
   - 時間複雜度：O(n×m×log(n×m))
   - 空間複雜度：O(n×m)
   - 學習重點：
     - 曼哈頓距離
     - BFS 應用
     - 矩陣座標處理

#### Medium 題目

1. [1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/) (Medium)

   - 核心技巧：BFS 最短路徑
   - 時間複雜度：O(n×m)
   - 空間複雜度：O(n×m)
   - 學習重點：
     - BFS 層次遍歷
     - 距離計算
     - 多方向移動處理

2. [743. Network Delay Time](https://leetcode.com/problems/network-delay-time/) (Medium)

   - 核心技巧：Dijkstra 算法
   - 時間複雜度：O(E log V)
   - 空間複雜度：O(V + E)
   - 學習重點：
     - Dijkstra 實現
     - 優先隊列使用
     - 加權圖處理

3. [787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/) (Medium)
   - 核心技巧：修改版 Bellman-Ford
   - 時間複雜度：O(K×E)
   - 空間複雜度：O(V)
   - 學習重點：
     - 限制條件下的最短路
     - 動態規劃思想
     - 狀態轉移設計

### 3. 拓撲排序練習（由易到難）

#### Easy 題目

1. [2192. All Ancestors of a Node in a Directed Acyclic Graph](https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/) (Easy)
   - 核心技巧：有向圖遍歷
   - 時間複雜度：O(V×(V+E))
   - 空間複雜度：O(V×V)
   - 學習重點：
     - 有向無環圖概念
     - 祖先節點的尋找
     - 依賴關係的處理

#### Medium 題目

1. [207. Course Schedule](https://leetcode.com/problems/course-schedule/) (Medium)

   - 核心技巧：環檢測
   - 時間複雜度：O(V + E)
   - 空間複雜度：O(V + E)
   - 學習重點：
     - 圖中環的檢測
     - DFS/BFS 實現選擇
     - 狀態標記技巧

2. [210. Course Schedule II](https://leetcode.com/problems/course-schedule-ii/) (Medium)
   - 核心技巧：拓撲排序實現
   - 時間複雜度：O(V + E)
   - 空間複雜度：O(V + E)
   - 學習重點：
     - 完整拓撲序列生成
     - 入度統計與更新
     - 隊列使用技巧

### 4. 並查集練習（由易到難）

#### Easy 題目

1. [1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/) (Easy)

   - 核心技巧：並查集基礎
   - 時間複雜度：O(V+E)
   - 空間複雜度：O(V)
   - 學習重點：
     - 並查集基本操作
     - 連通性判斷
     - 路徑存在性檢查

2. [2421. Number of Good Paths](https://leetcode.com/problems/number-of-good-paths/) (Easy)
   - 核心技巧：並查集應用
   - 時間複雜度：O(n×α(n))
   - 空間複雜度：O(n)
   - 學習重點：
     - 並查集進階應用
     - 連通分量處理
     - 路徑計數技巧

#### Medium 題目

1. [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/) (Medium)

   - 核心技巧：基礎並查集
   - 時間複雜度：O(N×α(N))
   - 空間複雜度：O(N)
   - 學習重點：
     - 並查集基本操作
     - 環的檢測
     - 路徑壓縮實現

2. [1319. Number of Operations to Make Network Connected](https://leetcode.com/problems/number-of-operations-to-make-network-connected/) (Medium)
   - 核心技巧：連通分量計數
   - 時間複雜度：O(N×α(N))
   - 空間複雜度：O(N)
   - 學習重點：
     - 並查集的應用
     - 連通性判斷
     - 冗餘連接計數

## Python 解題模板

### DFS 與 BFS 訪問標記時機的差異

在圖的遍歷中，DFS 和 BFS 在訪問標記（visited 標記）的時機上有重要差異：

#### DFS 訪問標記特點

- 處理節點時標記：在 DFS 中，我們在實際處理節點時才將其標記為已訪問 `if node not in visited: visited.add(node)`
- 原因：因為同一個節點可能被多次加入堆疊（stack），所以需要在處理時檢查以避免重複處理
- 特性：允許節點多次進入堆疊，但只處理一次

#### BFS 訪問標記特點

- 入佇列時標記：在 BFS 中，我們在將節點加入佇列（queue）的同時就將其標記為已訪問 `visited.add(next_node)`
- 原因：這樣可以確保每個節點只會被加入佇列一次，從佇列中取出的節點一定是已訪問過的
- 特性：每個節點最多只會進入佇列一次，提高了空間效率

#### 實作差異的影響

- BFS 不需要在 `node = queue.popleft()` 後檢查 `if node not in visited`
- BFS 的這種實作方式可以減少佇列中的元素數量，提高效率
- 兩種方法在功能上等價，但在特定場景下可能有效率差異

#### 為什麼 BFS 不會出現同一節點多次入佇列的情況

在 BFS 實作中，我們採用「先標記再加入」的順序：

```python
if next_node not in visited:
    visited.add(next_node)  # 立即標記為已訪問
    queue.append(next_node)  # 然後加入佇列
```

這種機制確保了同一節點不會被多次加入佇列：

1. 即時標記：發現未訪問的相鄰節點時，立即標記為已訪問，然後才加入佇列
2. 層次遍歷特性：BFS 按層次遍歷，處理第 n 層節點時，所有第 n-1 層節點都已被標記為已訪問

3. 多路徑保護：若節點 A 有多個鄰居都指向節點 B：
   - 當第一個鄰居發現 B 時，B 被標記為已訪問並加入佇列
   - 當後續鄰居再次發現 B 時，因為 B 已被標記為已訪問，不會再次加入佇列

相比之下，DFS 允許同一節點多次入堆疊：

```python
node = stack.pop()
if node not in visited:  # 取出後才檢查
    visited.add(node)
    for next_node in graph[node]:
        if next_node not in visited:
            stack.append(next_node)  # 只檢查但不標記
```

DFS 中同一節點可多次入堆疊的原因：

1. 延遲標記：DFS 在實際處理節點時才標記為已訪問，而不是在加入堆疊時
2. 深度優先特性：DFS 可能通過不同路徑多次「發現」同一節點，在發現時只檢查但不標記
3. 堆疊後進先出：由於堆疊的特性，將一個節點的所有鄰居加入後，會先處理最後加入的節點

#### 實際例子

考慮簡單圖：A → B → C，且 A 也直接連接到 C (A → C)

在 BFS 中：

1. 訪問 A，將 B 和 C 標記為已訪問並加入佇列
2. 訪問 B，檢查 C，但 C 已被標記為已訪問，不會再次加入佇列
3. 訪問 C

在 DFS 中：

1. 訪問 A，將 C 和 B 加入堆疊（假設先加入 C 再加入 B）
2. 取出並訪問 B，將 C 加入堆疊（此時 C 在堆疊中出現兩次）
3. 取出並訪問 C
4. 取出第二個 C，發現已訪問，跳過

## 現實問題轉換為圖的詳細指南

圖論是一個強大的工具，能幫助我們將各種看似無關的問題模型化並求解。以下是如何系統性地將問題轉換為圖的詳細步驟與案例分析：

### 1. 識別節點（Nodes）

節點通常代表問題中的「實體」或「狀態」，可能是：

- **物理實體**：城市、電腦、人、產品等
- **抽象概念**：任務、課程、狀態等
- **位置**：地圖上的點、二維網格的格子、迷宮中的位置等
- **時間點**：事件發生的時刻
- **組合狀態**：遊戲中的盤面、多個變量的狀態組合等

**示例分析**：

- 在社交網絡問題中，節點是「人」
- 在課程安排問題中，節點是「課程」
- 在迷宮問題中，節點是「格子位置」
- 在八數碼問題中，節點是「盤面狀態」

### 2. 識別邊（Edges）

邊代表節點間的「關係」或「轉換可能性」，可能表示：

- **連接關係**：道路、網絡連線、朋友關係等
- **依賴關係**：先修課程、任務前置條件等
- **轉換可能性**：狀態間的一步變化、操作後的新狀態等
- **資源流動**：資金流動、資訊傳播、物資運輸等
- **影響關係**：因果關係、操作結果等

**示例分析**：

- 在社交網絡中，邊表示「朋友關係」
- 在課程安排中，邊表示「先修依賴」
- 在迷宮問題中，邊表示「可行的移動」
- 在網路流問題中，邊表示「資源可流動的管道」

### 3. 確定圖的類型

根據問題特性確定圖的結構類型：

- **有向圖 vs 無向圖**：關係是單向還是雙向？

  - 「朋友關係」通常是無向（雙向）
  - 「追隨關係」通常是有向（單向）

- **加權圖 vs 非加權圖**：關係是否有強度或成本？

  - 「城市間距離」需要加權
  - 「朋友關係存在與否」可以不加權

- **連通圖 vs 非連通圖**：是否所有節點都可以相互到達？
  - 互聯網中的電腦可能形成多個隔離的網絡
- **循環圖 vs 無環圖**：是否存在循環路徑？
  - 任務依賴通常不能形成環（否則無法完成）
  - 道路網絡通常包含環路

### 4. 轉換實例案例分析

#### 案例一：課程安排問題（拓撲排序）

**問題描述**：有 n 門課程，部分課程有先修要求。判斷是否能完成所有課程，若能，給出一個可行的修課順序。

**圖轉換**：

- **節點**：每門課程
- **邊**：課程間的先修關係（有向）
- **圖類型**：有向無環圖（DAG）

**求解思路**：

1. 檢測圖中是否有環（如果有環，則無法完成所有課程）
2. 如果無環，使用拓撲排序找出一個可行的修課順序

#### 案例二：網絡延遲問題（最短路徑）

**問題描述**：有 n 個網絡節點，連接它們的有向加權邊代表訊息傳播延遲。求從源節點 k 發出信號，到達所有節點的最短時間。

**圖轉換**：

- **節點**：網絡中的電腦/路由器
- **邊**：網絡連接（有向、加權）
- **圖類型**：有向加權圖

**求解思路**：

1. 使用 Dijkstra 算法找出從源節點到所有其他節點的最短路徑
2. 最終結果是最大的那個最短路徑值（最後一個節點收到信號的時間）

#### 案例三：朋友圈問題（連通分量）

**問題描述**：有 n 個人，給定他們之間的朋友關係，求朋友圈的數量（直接或間接相連的人在同一朋友圈）。

**圖轉換**：

- **節點**：每個人
- **邊**：朋友關係（無向）
- **圖類型**：無向圖

**求解思路**：

1. 使用深度優先搜索（DFS）或並查集找出所有連通分量
2. 連通分量的數量即為朋友圈的數量

#### 案例四：詞語演變問題（最短路徑）

**問題描述**：給定起始單詞、目標單詞和一個字典，每次只能改變一個字母，且改變後的單詞必須在字典中，求從起始單詞到目標單詞的最短轉換序列長度。

**圖轉換**：

- **節點**：字典中的每個單詞
- **邊**：如果兩個單詞只相差一個字母，則它們之間有一條邊
- **圖類型**：無向非加權圖

**求解思路**：

1. 建立單詞之間的圖（僅連接相差一個字母的單詞）
2. 使用 BFS 找出從起始單詞到目標單詞的最短路徑

#### 案例五：城市連通問題（最小生成樹）

**問題描述**：有 n 個城市，需要建設道路使所有城市互相連通，每條道路有一個建設成本，求最小總成本。

**圖轉換**：

- **節點**：每個城市
- **邊**：可能的道路連接（無向、加權）
- **圖類型**：無向加權圖

**求解思路**：

1. 使用 Kruskal 算法或 Prim 算法求最小生成樹
2. 最小生成樹的總權重即為所需的最小總成本

### 5. 識別圖問題的關鍵詞

在實際問題中，以下關鍵詞通常暗示了圖相關的解法：

- **連接、路徑、網絡**：通常需要圖的連通性分析
- **最短、最小成本**：通常需要最短路徑算法
- **依賴、先決條件**：通常需要拓撲排序
- **群組、集合、分類**：通常需要連通分量或並查集
- **循環、環**：通常需要環檢測算法
- **最小連接成本**：通常需要最小生成樹

### 6. 圖算法與問題類型對應表

| 問題類型   | 常用算法                          | 典型例子             |
| ---------- | --------------------------------- | -------------------- |
| 連通性檢查 | DFS, BFS, 並查集                  | 朋友圈, 島嶼數量     |
| 路徑存在   | DFS, BFS                          | 迷宮問題, 路徑存在性 |
| 最短路徑   | BFS(無權), Dijkstra, Bellman-Ford | 詞語轉換, 網絡延遲   |
| 拓撲排序   | Kahn's Algorithm, DFS             | 課程排序, 任務調度   |
| 環檢測     | DFS, 並查集                       | 課程可行性, 冗餘連接 |
| 最小生成樹 | Kruskal, Prim                     | 城市間最小連接成本   |
| 二分圖檢測 | BFS, DFS                          | 偏見劃分, 工作分配   |
| 強連通分量 | Tarjan's Algorithm, Kosaraju      | 社區發現, 網站分組   |

## 靜態分析 vs 動態分析

當我們遇到一個新問題時，可以先問自己：

- 這是關於「現有實體之間關係」的問題嗎？ → 靜態分析
  - 例如：找最小生成樹、計算最短路徑、查找連通分量
- 這是關於「系統如何從一個狀態轉移到另一個狀態」的問題嗎？ → 動態分析
  - 例如：八數碼問題、河內塔、狀態機設計

這種分類方法能幫助我們更快地識別問題的本質，從而選擇合適的建模方式和解決算法。它提供了一個直觀的思維框架，讓我們能夠系統性地應對各種圖論問題。

### 靜態分析（Structure-Relationship Graph）

- **節點**：實體物件或概念（人、城市、電腦等）
- **邊**：實體間的關係或連接（朋友關係、道路、網路連接等）
- **特點**：圖的結構反映的是問題的「當前狀態」或「固有結構」
- **例子**：社交網路、城市路網、網路拓撲、電路圖

### 動態分析（State-Transition Graph）

- **節點**：系統的可能狀態（棋盤局面、遊戲狀態、問題階段）
- **邊**：從一個狀態到另一個狀態的轉換（下一步棋、操作、決策）
- **特點**：圖的結構反映的是問題的「可能演化」或「決策空間」
- **例子**：棋類遊戲、迷宮問題、狀態機、排列組合問題

### 這種思路的應用與優勢

- 問題建模

  - 遇到新問題時，先判斷是「實體關係」還是「狀態轉換」
  - 根據不同類型選擇合適的建模方式

- 動態規劃與圖論的結合

  - 許多動態規劃問題可以視為在「狀態轉換圖」上尋找路徑
  - 子問題重疊對應圖中的節點被多次訪問

- 搜索空間的優化
  - 在狀態轉換圖中，識別和剪枝無效狀態
  - 通過啟發式評估函數優先探索更有希望的路徑

### 靜態分析應用

- **知識圖譜**：

  - **節點**：概念、實體
  - **邊**：關係（「是一個」、「屬於」、「包含」等）

- **社區檢測**：

  - **節點**：社交網絡中的用戶
  - **邊**：社交互動
  - **應用**：自然形成的社區識別，有助於社交推薦

- **網絡流量分析**：
  - **節點**：網路設備
  - **邊**：數據流連接
  - **應用**：識別瓶頸、優化網絡結構

### 動態分析應用

- **自然語言處理中的文本生成**：

  - **節點**：文本生成的每個可能狀態
  - **邊**：添加一個詞的動作
  - **應用**：語言模型、自動補全

- **遺傳算法路徑規劃**：

  - **節點**：問題解決方案的狀態
  - **邊**：突變或交叉操作
  - **應用**：旅行商問題、資源分配優化

- **程序驗證**：

  - **節點**：程序可能的執行狀態
  - **邊**：執行指令造成的狀態變化
  - **應用**：檢測潛在的死鎖或安全漏洞

- **數據轉換工作流**：
  - **節點**：數據的處理狀態
  - **邊**：數據轉換操作
  - **應用**：ETL 流程、數據管道優化
